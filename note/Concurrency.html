<!DOCTYPE html>
<!-- saved from url=(0062)https://people.cs.pitt.edu/~xianeizhang/notes/Concurrency.html -->
<html class="gr__people_cs_pitt_edu"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title>Concurrency</title>
<style type="text/css">
body {
  font-family: Helvetica, arial, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  padding-top: 10px;
  padding-bottom: 10px;
  background-color: white;
  padding: 30px; }

body > *:first-child {
  margin-top: 0 !important; }
body > *:last-child {
  margin-bottom: 0 !important; }

a {
  color: #4183C4; }
a.absent {
  color: #cc0000; }
a.anchor {
  display: block;
  padding-left: 30px;
  margin-left: -30px;
  cursor: pointer;
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0; }

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
  cursor: text;
  position: relative; }

h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor {
  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA09pVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoMTMuMCAyMDEyMDMwNS5tLjQxNSAyMDEyLzAzLzA1OjIxOjAwOjAwKSAgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OUM2NjlDQjI4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OUM2NjlDQjM4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo5QzY2OUNCMDg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo5QzY2OUNCMTg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PsQhXeAAAABfSURBVHjaYvz//z8DJYCRUgMYQAbAMBQIAvEqkBQWXI6sHqwHiwG70TTBxGaiWwjCTGgOUgJiF1J8wMRAIUA34B4Q76HUBelAfJYSA0CuMIEaRP8wGIkGMA54bgQIMACAmkXJi0hKJQAAAABJRU5ErkJggg==) no-repeat 10px center;
  text-decoration: none; }

h1 tt, h1 code {
  font-size: inherit; }

h2 tt, h2 code {
  font-size: inherit; }

h3 tt, h3 code {
  font-size: inherit; }

h4 tt, h4 code {
  font-size: inherit; }

h5 tt, h5 code {
  font-size: inherit; }

h6 tt, h6 code {
  font-size: inherit; }

h1 {
  font-size: 28px;
  color: black; }

h2 {
  font-size: 24px;
  border-bottom: 1px solid #cccccc;
  color: black; }

h3 {
  font-size: 18px; }

h4 {
  font-size: 16px; }

h5 {
  font-size: 14px; }

h6 {
  color: #777777;
  font-size: 14px; }

p, blockquote, ul, ol, dl, li, table, pre {
  margin: 15px 0; }

hr {
  background: transparent url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAECAYAAACtBE5DAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OENDRjNBN0E2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OENDRjNBN0I2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4Q0NGM0E3ODY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4Q0NGM0E3OTY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqqezsUAAAAfSURBVHjaYmRABcYwBiM2QSA4y4hNEKYDQxAEAAIMAHNGAzhkPOlYAAAAAElFTkSuQmCC) repeat-x 0 0;
  border: 0 none;
  color: #cccccc;
  height: 4px;
  padding: 0;
}

body > h2:first-child {
  margin-top: 0;
  padding-top: 0; }
body > h1:first-child {
  margin-top: 0;
  padding-top: 0; }
  body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0; }
body > h3:first-child, body > h4:first-child, body > h5:first-child, body > h6:first-child {
  margin-top: 0;
  padding-top: 0; }

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0; }

h1 p, h2 p, h3 p, h4 p, h5 p, h6 p {
  margin-top: 0; }

li p.first {
  display: inline-block; }
li {
  margin: 0; }
ul, ol {
  padding-left: 30px; }

ul :first-child, ol :first-child {
  margin-top: 0; }

dl {
  padding: 0; }
  dl dt {
    font-size: 14px;
    font-weight: bold;
    font-style: italic;
    padding: 0;
    margin: 15px 0 5px; }
    dl dt:first-child {
      padding: 0; }
    dl dt > :first-child {
      margin-top: 0; }
    dl dt > :last-child {
      margin-bottom: 0; }
  dl dd {
    margin: 0 0 15px;
    padding: 0 15px; }
    dl dd > :first-child {
      margin-top: 0; }
    dl dd > :last-child {
      margin-bottom: 0; }

blockquote {
  border-left: 4px solid #dddddd;
  padding: 0 15px;
  color: #777777; }
  blockquote > :first-child {
    margin-top: 0; }
  blockquote > :last-child {
    margin-bottom: 0; }

table {
  padding: 0;border-collapse: collapse; }
  table tr {
    border-top: 1px solid #cccccc;
    background-color: white;
    margin: 0;
    padding: 0; }
    table tr:nth-child(2n) {
      background-color: #f8f8f8; }
    table tr th {
      font-weight: bold;
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr td {
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr th :first-child, table tr td :first-child {
      margin-top: 0; }
    table tr th :last-child, table tr td :last-child {
      margin-bottom: 0; }

img {
  max-width: 100%; }

span.frame {
  display: block;
  overflow: hidden; }
  span.frame > span {
    border: 1px solid #dddddd;
    display: block;
    float: left;
    overflow: hidden;
    margin: 13px 0 0;
    padding: 7px;
    width: auto; }
  span.frame span img {
    display: block;
    float: left; }
  span.frame span span {
    clear: both;
    color: #333333;
    display: block;
    padding: 5px 0 0; }
span.align-center {
  display: block;
  overflow: hidden;
  clear: both; }
  span.align-center > span {
    display: block;
    overflow: hidden;
    margin: 13px auto 0;
    text-align: center; }
  span.align-center span img {
    margin: 0 auto;
    text-align: center; }
span.align-right {
  display: block;
  overflow: hidden;
  clear: both; }
  span.align-right > span {
    display: block;
    overflow: hidden;
    margin: 13px 0 0;
    text-align: right; }
  span.align-right span img {
    margin: 0;
    text-align: right; }
span.float-left {
  display: block;
  margin-right: 13px;
  overflow: hidden;
  float: left; }
  span.float-left span {
    margin: 13px 0 0; }
span.float-right {
  display: block;
  margin-left: 13px;
  overflow: hidden;
  float: right; }
  span.float-right > span {
    display: block;
    overflow: hidden;
    margin: 13px auto 0;
    text-align: right; }

code, tt {
  margin: 0 2px;
  padding: 0 5px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px; }

pre code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent; }

.highlight pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px; }

pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px; }
  pre code, pre tt {
    background-color: transparent;
    border: none; }

sup {
    font-size: 0.83em;
    vertical-align: super;
    line-height: 0;
}
* {
	-webkit-print-color-adjust: exact;
}
@media screen and (min-width: 914px) {
    body {
        width: 854px;
        margin:0 auto;
    }
}
@media print {
	table, pre {
		page-break-inside: avoid;
	}
	pre {
		word-wrap: break-word;
	}
}
</style>
<style type="text/css">
/**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */

code[class*="language-"],
pre[class*="language-"] {
	color: black;
	text-shadow: 0 1px white;
	font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
	direction: ltr;
	text-align: left;
	white-space: pre;
	word-spacing: normal;
	word-break: normal;
	word-wrap: normal;
	line-height: 1.5;

	-moz-tab-size: 4;
	-o-tab-size: 4;
	tab-size: 4;

	-webkit-hyphens: none;
	-moz-hyphens: none;
	-ms-hyphens: none;
	hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
	text-shadow: none;
	background: #b3d4fc;
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
	text-shadow: none;
	background: #b3d4fc;
}

@media print {
	code[class*="language-"],
	pre[class*="language-"] {
		text-shadow: none;
	}
}

/* Code blocks */
pre[class*="language-"] {
	padding: 1em;
	margin: .5em 0;
	overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
	background: #f5f2f0;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
	padding: .1em;
	border-radius: .3em;
	white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
	color: slategray;
}

.token.punctuation {
	color: #999;
}

.namespace {
	opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
	color: #905;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
	color: #690;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
	color: #a67f59;
	background: hsla(0, 0%, 100%, .5);
}

.token.atrule,
.token.attr-value,
.token.keyword {
	color: #07a;
}

.token.function {
	color: #DD4A68;
}

.token.regex,
.token.important,
.token.variable {
	color: #e90;
}

.token.important,
.token.bold {
	font-weight: bold;
}
.token.italic {
	font-style: italic;
}

.token.entity {
	cursor: help;
}
</style>
</head>
<body data-gr-c-s-loaded="true">
<h1 id="toc_0">Concurrency</h1>

<h2 id="toc_1">Table of contents</h2>

<ol>
<li><a href="https://people.cs.pitt.edu/~xianeizhang/notes/Concurrency.html#overview">Overview</a></li>
<li><a href="https://people.cs.pitt.edu/~xianeizhang/notes/Concurrency.html#fut-pro">future-promise</a></li>
<li><a href="https://people.cs.pitt.edu/~xianeizhang/notes/Concurrency.html#packaged">std::packaged_task</a></li>
<li><a href="https://people.cs.pitt.edu/~xianeizhang/notes/Concurrency.html#async">async()</a></li>
<li><a href="https://people.cs.pitt.edu/~xianeizhang/notes/Concurrency.html#threads">Threads</a></li>
<li><a href="https://people.cs.pitt.edu/~xianeizhang/notes/Concurrency.html#prob">Concurrency problem</a></li>
<li><a href="https://people.cs.pitt.edu/~xianeizhang/notes/Concurrency.html#mut-lock">Mutex and locks</a></li>
<li><a href="https://people.cs.pitt.edu/~xianeizhang/notes/Concurrency.html#cond">Conditional variables</a></li>
<li><a href="https://people.cs.pitt.edu/~xianeizhang/notes/Concurrency.html#atomics">Atomics</a></li>
</ol>

<h2 id="toc_2"><a name="overview"></a> 1. Overview <a href="https://people.cs.pitt.edu/~xianeizhang/notes/Concurrency.html#top">↑top</a></h2>

<p>The C++11 standard library provides several mechanisms to support concurrency. The first is <strong><code>std::thread</code></strong>, which together with sync objects (<code>std::mutex</code>, <code>std::lock_guards</code> and <code>std::condition_variables</code>, etc) offers a <strong>thread-based</strong> approach to achieve concurrency. </p>

<p>However, working at the level of threads and locks can be quite tricky, and thus a higher-level of abstraction, <strong>task-based</strong> concurrency, is also supported in C++11, in the form of promises and futures. <strong><code>std::promise&lt;T&gt;</code></strong> and <strong><code>std::future&lt;T&gt;</code></strong> work in pairs to separate the act of calling a func from the act of waiting for the call rsts.</p>

<p>Class <strong><code>std::packaged_task&lt;T&gt;</code></strong> makes codes more readable; it is a container for a task and its promise. The template type is the type of the task func, and it automatically creates and manages a <code>std::promise&lt;T&gt;</code> for use.</p>

<p>Things become much simpiler if we use the <strong><code>std::async()</code></strong> func, which hides all the implementation, platform specific details. It takes as input a callable object and returns a future that will contain the return value. </p>

<h2 id="toc_3"><a name="fut-pro"></a> 2. future - promise <a href="https://people.cs.pitt.edu/~xianeizhang/notes/Concurrency.html#top">↑top</a></h2>

<h3 id="toc_4">(i) overview</h3>

<figure>
  <center>
  <img src="./Concurrency_files/task_para.png" alt="The Pulpit Rock" width="400">
  <figcaption>Fig.1 - <b>Info flow of task-based concurrency</b>. </figcaption>
  </center>
</figure>

<p>A <strong><code>std::promise&lt;T&gt;</code></strong> obj represents a result in the <em>callee</em>-side of the asynchronous call, and it is the channel for passing the result asynchronously to the caller. When the task completes, it puts its result into a promise object calling <code>promise::set_value</code>.</p>

<p>When the caller finally needs to access the result, it will call the blocking <strong><code>future::get</code></strong> to retrieve it. If the task has already completed, the result will be immediately available, ow, the caller thread will suspend until the result becomes available.</p>

<p>This <strong>shared state</strong> can be associated to a future object by calling member <code>get_future</code>. After the call, both objects share the same shared state:<br>
- The <u>promise</u> object is the asynchronous <u>provider</u> and is expected to set a value for the shared state at some point.<br>
- The <u>future</u> object is an asynchronous return object that can <u>retrieve</u> the value of the shared state, waiting for it to be ready, if necessary.</p>

<pre class=" language-cpp"><code class=" language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;future&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;numeric&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
 
<span class="token keyword">void</span> <span class="token function">accumulate</span><span class="token punctuation">(</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">::</span>iterator first<span class="token punctuation">,</span>
                std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">::</span>iterator last<span class="token punctuation">,</span>
                std<span class="token operator">::</span>promise<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> accumulate_promise<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> sum <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">accumulate</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span> last<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    accumulate_promise<span class="token punctuation">.</span><span class="token function">set_value</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Notify future</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> numbers <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//create promise</span>
    std<span class="token operator">::</span>promise<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> accumulate_promise<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//engagement with future</span>
    std<span class="token operator">::</span>future<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> accumulate_future <span class="token operator">=</span> accumulate_promise<span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    std<span class="token operator">::</span>thread <span class="token function">work_thread</span><span class="token punctuation">(</span>accumulate<span class="token punctuation">,</span> numbers<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> 
                            numbers<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>accumulate_promise<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                            
    accumulate_future<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// wait for result</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"result="</span> <span class="token operator">&lt;&lt;</span> accumulate_future<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
    work_thread<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment" spellcheck="true">// wait for thread completion</span>
<span class="token punctuation">}</span></code></pre>

<h3 id="toc_5">(ii) std::promise&lt;T&gt;</h3>

<p>The class template <strong><code>std::promise</code></strong> provides a facility to store a value or an exception that is later acquired asyn via a <code>std::future</code> obj created by the <code>std::promise</code> obj. Each promise is associated with a shared state, which contains some state info and a result which may be not yet evaluated, to be a value or an exception.</p>

<p>The promise is the "push" end of promise-future communication channel: the operation that stores a value in the shared state synchronizes-with the successful return from any func that is waiting on the shared state (e.g., <code>std::future::get</code>).</p>

<ul>
<li><strong><code>get_future</code></strong>: returns a future obj associated with the promised result;</li>
<li><strong><code>set_value</code></strong>: atomically stores the result into the shared state and makes the state ready;</li>
<li><strong><code>set_value_at_thread_exit</code></strong>: stores the value into the shared state without making the state ready immediately. The state is made ready when the current thread exits, after all variables with thread-local storage duration have been destroyed;</li>
<li><p><strong><code>set_exception</code></strong>: atomically stores the exception ptr into the shared state and makes the state ready;</p>

<pre class=" language-cpp"><code class=" language-cpp">std<span class="token operator">::</span>promise<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> result<span class="token punctuation">;</span>

std<span class="token operator">::</span>thread <span class="token function">t</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// code that may throw</span>
            <span class="token keyword">throw</span> std<span class="token operator">::</span><span class="token function">runtime_error</span><span class="token punctuation">(</span><span class="token string">"Example"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">// store anything thrown in the promise</span>
                result<span class="token punctuation">.</span><span class="token function">set_exception</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">current_exception</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// set_exception() may throw too</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">try</span> <span class="token punctuation">{</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> result<span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>exception<span class="token operator">&amp;</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Exception from the thread: "</span> <span class="token operator">&lt;&lt;</span> e<span class="token punctuation">.</span><span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li>
<li><p><strong><code>set_exception_at_thread_exit</code></strong>: similar to that of value.</p></li>
</ul>

<h3 id="toc_6">(iii) std::future&lt;T&gt;</h3>

<p>The class template <code>std::future</code> provides a mechanism to access the result of asynchronous operations:</p>

<ul>
<li>an asynchronous operation (created via <code>std::async</code>, <code>std::packaged_task</code>, or <code>std::promise</code>) can provide a <code>std::future</code> obj to the creator of that asyn operation;</li>
<li>the creator of the asyn operation can then use a variety of methods to query, wait for, or extract a value from the <code>std::future</code>. These methods may block if the asyn operation has not yet provided a value;</li>
<li>when the asyn operation is ready to send a rst to the creater, it can do so by modifying <em>shared state</em> (e.g., <code>std::promise::set_value</code>) that is linked to the creator's <code>std::future</code>.</li>
</ul>

<p>Member functions:</p>

<ul>
<li><strong>get()</strong>: returns the result; you can call <code>get()</code> for <u>only once</u>, because <code>get()</code> invalidates the future's state;</li>
<li><p><strong>share()</strong>: transfers the shared state from <code>*this</code> to a <code>shared_future</code> and returns it;</p>

<pre class=" language-cpp"><code class=" language-cpp"><span class="token keyword">int</span> <span class="token function">get_value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

std<span class="token operator">::</span>future<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> fut <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">async</span><span class="token punctuation">(</span>get_value<span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>shared_future<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> shfut <span class="token operator">=</span> fut<span class="token punctuation">.</span><span class="token function">share</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//shared futures can be accessed multi times</span>
std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"value: "</span> <span class="token operator">&lt;&lt;</span> shfut<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"its double: "</span> <span class="token operator">&lt;&lt;</span> shfut<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">2</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span></code></pre></li>
<li><p><strong>valid()</strong>: checks if the future has a shared state;</p></li>
<li><p><strong>wait()</strong>: waits for the result to become available;</p></li>
<li><p><strong>wait_for(timeout_duration)</strong>: waits for teh result to become available. Blocks until specified <code>timeout_duration</code> has elapsed or the result becomes available, whichever comes first. Returns value (<code>deferred</code>, <code>ready</code> or <code>timeout</code>) identifies the state of the result.</p>

<pre class=" language-cpp"><code class=" language-cpp">std<span class="token operator">::</span>future<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> future <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">async</span><span class="token punctuation">(</span>std<span class="token operator">::</span>launch<span class="token operator">::</span>async<span class="token punctuation">,</span>
    <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> std<span class="token operator">::</span>this_thread<span class="token operator">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>std<span class="token operator">::</span>chrono<span class="token operator">::</span><span class="token function">seconds</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">8</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"waiting ...\n"</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>future_status status<span class="token punctuation">;</span>
<span class="token keyword">do</span><span class="token punctuation">{</span>
    status <span class="token operator">=</span> future<span class="token punctuation">.</span><span class="token function">wait_for</span><span class="token punctuation">(</span>std<span class="token operator">::</span>chrono<span class="token operator">::</span><span class="token function">seconds</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>status <span class="token operator">==</span> std<span class="token operator">::</span>future_status<span class="token operator">::</span>deferred<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"deferred\n"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>status <span class="token operator">==</span> std<span class="token operator">::</span>future_status<span class="token operator">::</span>timeout<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"timeout\n"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>status <span class="token operator">==</span> std<span class="token operator">::</span>future_status<span class="token operator">::</span>ready<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ready!\n"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>status <span class="token operator">!=</span> std<span class="token operator">::</span>future_status<span class="token operator">::</span>ready<span class="token punctuation">)</span><span class="token punctuation">;</span>

std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"result is "</span> <span class="token operator">&lt;&lt;</span> future<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span></code></pre></li>
<li><p><strong>wait_util(timeout_time)</strong>: waits for the rst to become available. Similar to <code>wait_for</code>.</p>

<pre class=" language-cpp"><code class=" language-cpp"><span class="token comment" spellcheck="true">//try to call func asynchronously</span>
std<span class="token operator">::</span>future<span class="token operator">&lt;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&gt;</span> <span class="token function">f</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">async</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token comment" spellcheck="true">//wait-1</span>
f<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//wait for func to be done (might start bkgd task)</span>

<span class="token comment" spellcheck="true">//wait-2: wait for a limited time</span>
f<span class="token punctuation">.</span><span class="token function">wait_for</span><span class="token punctuation">(</span>std<span class="token operator">::</span>chrono<span class="token operator">::</span><span class="token function">seconds</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//wait for at most 10 secs for func</span>

<span class="token comment" spellcheck="true">//wait-3: wait until a specific timepoint has reached</span>
f<span class="token punctuation">.</span><span class="token function">wait_until</span><span class="token punctuation">(</span>std<span class="token operator">::</span>system<span class="token operator">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span>std<span class="token operator">::</span>chrono<span class="token operator">::</span><span class="token function">minutes</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li>
</ul>

<h2 id="toc_7"><a name="packaged"></a> 3. std::packaged_task <a href="https://people.cs.pitt.edu/~xianeizhang/notes/Concurrency.html#top">↑top</a></h2>

<p><strong><code>std::package_task</code></strong> wraps any callable (func, lambda, bind expr, or another func obj) so that it can be invoked asyn. Its return value or exception thrown is stored in a shared state which can be accessed through <code>std::future</code> objs.</p>

<ul>
<li><strong>get_future</strong>: returns a future associated with the promised result; <code>get_future</code> can be called only once for each packaged_task;</li>
<li><strong>make_ready_at_thread_exit</strong>: executes the func ensuring that the rst is ready only after the current threads exits and all objs of thread local storage duration are destroyed;</li>
<li><strong>reset</strong>: resets the state abandoning any stored rsts of prev executions</li>
</ul>

<pre class=" language-cpp"><code class=" language-cpp"><span class="token comment" spellcheck="true">// unique function to avoid disambiguating the std::pow overload set</span>
<span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> std<span class="token operator">::</span><span class="token function">pow</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
 
<span class="token keyword">void</span> <span class="token function">task_lambda</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token operator">::</span>packaged_task<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> <span class="token function">task</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> std<span class="token operator">::</span><span class="token function">pow</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span>future<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> result <span class="token operator">=</span> task<span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
    <span class="token function">task</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"task_lambda:\t"</span> <span class="token operator">&lt;&lt;</span> result<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">void</span> <span class="token function">task_bind</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token operator">::</span>packaged_task<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> <span class="token function">task</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">bind</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span>future<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> result <span class="token operator">=</span> task<span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
    <span class="token function">task</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"task_bind:\t"</span> <span class="token operator">&lt;&lt;</span> result<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">void</span> <span class="token function">task_thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token operator">::</span>packaged_task<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> <span class="token function">task</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span>future<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> result <span class="token operator">=</span> task<span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
    std<span class="token operator">::</span>thread <span class="token function">task_td</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    task_td<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"task_thread:\t"</span> <span class="token operator">&lt;&lt;</span> result<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">task_lambda</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">task_bind</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">task_thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>

<h2 id="toc_8"><a name="async"></a> 4. async() <a href="https://people.cs.pitt.edu/~xianeizhang/notes/Concurrency.html#top">↑top</a></h2>

<p>With <code>packaged_task</code>, we still have to manually create the threads to run the task, and decide on which thread the task will run. Things can be much simpler using the high-level <code>std::async()</code> interface.</p>

<ul>
<li><code>async()</code> provides an interface to let a piece of functionality, a callable obj, run in the background as a separate thread, if psbl;</li>
<li>class <code>future&lt;&gt;</code> allows you to wait for the thread to be finished and provides access to its outcome: return value of exception, if any.</li>
</ul>

<h3 id="toc_9">(i) example</h3>

<pre class=" language-cpp"><code class=" language-cpp"><span class="token keyword">int</span> doSomething <span class="token punctuation">(</span><span class="token keyword">char</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//...</span>
    <span class="token keyword">return</span> c<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> func1 <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> func2 <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token string">'+'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//start func1 asynchronously (now or later or never)</span>
    std<span class="token operator">::</span>future<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">result1</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">async</span><span class="token punctuation">(</span>func1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//call func2 synchronously (here and now)</span>
    <span class="token keyword">int</span> result2 <span class="token operator">=</span> <span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//print result (wait for func1() to finish and add its result to result2</span>
    <span class="token keyword">int</span> result <span class="token operator">=</span> result1<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> result2<span class="token punctuation">;</span>
    
    cout <span class="token operator">&lt;&lt;</span> result <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>

<p>instead of calling: <code>int result = func1() + func2();</code>, we call:</p>

<pre class=" language-cpp"><code class=" language-cpp">std<span class="token operator">::</span>future<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">result1</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">async</span><span class="token punctuation">(</span>func1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> result2 <span class="token operator">=</span> <span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> result <span class="token operator">=</span> result1<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> result2<span class="token punctuation">;</span></code></pre>

<p><code>func1()</code> is tried to start in the background, using <code>std::async</code>, and assign the result to an obj of class <code>std::future</code>.</p>

<p>With the call of <code>get()</code>, one of the three things might happen:</p>

<ul>
<li>if <code>func1()</code> was started with <code>async()</code> in a separate thread and has already finished, we immediately get its result;</li>
<li>if <code>func1()</code> was started but has not finished yet, <code>get()</code> blocks and waits for its end and yields the result;</li>
<li>if <code>func1()</code> was not started yet, it will be forced to start now and, like a synchronous func call, <code>get()</code> will block until it yields the result.</li>
</ul>

<p>Without calling <code>get()</code>, there is no guarantee that <code>func1()</code> will ever be called. We have to ensure that we ask for the result of a functionality started with <code>async()</code> no earlier than necessary:</p>

<pre class=" language-cpp"><code class=" language-cpp">std<span class="token operator">::</span>future<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">result1</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">async</span><span class="token punctuation">(</span>func1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//might call func2() after func1() ends</span>
<span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> result1<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

<p>To have the best effect, in general, we should maximize the distance between calling <code>async()</code> and calling <code>get</code>, i.e., <strong>call early and return late</strong>.</p>

<p>The object passed to <code>async</code> may be any type of callable object: function, member func, func object, or lambda (<code>std::async([]{ ... })</code>).</p>

<h3 id="toc_10">(ii) launch policies</h3>

<p>The exact behavior of <code>async()</code> is complex and highly depends on the lanunch policy, which can be passed as the first optional argument.</p>

<p><code>async (launch policy, Fn&amp;&amp; fn, Args&amp;&amp; ...args</code></p>

<ul>
<li><strong>Asynchronous</strong>: <code>launch::async</code>, launches a new thread to call <code>fn</code> (as if a thread obj is constructed with <code>fn</code> and <code>args</code> as arguments, and accessing the shared state of the returned <code>future</code> joins it);</li>
</ul>

<pre class=" language-cpp"><code class=" language-cpp"> <span class="token keyword">void</span> print_ten <span class="token punctuation">(</span><span class="token keyword">char</span> c<span class="token punctuation">,</span> <span class="token keyword">int</span> ms<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token operator">::</span>this_thread<span class="token operator">::</span>sleep_for <span class="token punctuation">(</span>std<span class="token operator">::</span>chrono<span class="token operator">::</span><span class="token function">milliseconds</span><span class="token punctuation">(</span>ms<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> c<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> main <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"with launch::async:\n"</span><span class="token punctuation">;</span>
  std<span class="token operator">::</span>future<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">&gt;</span> foo <span class="token operator">=</span> std<span class="token operator">::</span>async <span class="token punctuation">(</span>std<span class="token operator">::</span>launch<span class="token operator">::</span>async<span class="token punctuation">,</span>print_ten<span class="token punctuation">,</span><span class="token string">'*'</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  std<span class="token operator">::</span>future<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">&gt;</span> bar <span class="token operator">=</span> std<span class="token operator">::</span>async <span class="token punctuation">(</span>std<span class="token operator">::</span>launch<span class="token operator">::</span>async<span class="token punctuation">,</span>print_ten<span class="token punctuation">,</span><span class="token string">'@'</span><span class="token punctuation">,</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// async "get" (wait for foo and bar to be ready):</span>
  foo<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  bar<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"\n\n"</span><span class="token punctuation">;</span> 
  </code></pre>

<ul>
<li><strong>Deferred</strong>: <code>launch::deferred</code>, the call to <code>fn</code> is deferred until the shared state of the returned <code>future</code> is accessed (with <code>wait</code> or <code>get</code>). At that point, <code>fn</code> is called and the func is no longer considered deferred. When this call returns, the shared state of the returned <code>future</code> is made ready;</li>
<li><strong>Automatic</strong>: <code>launch::async|launch::deferred</code>, the func chooses the policy auto (at some point). </li>
</ul>

<pre class=" language-cpp"><code class=" language-cpp"><span class="token keyword">void</span> print_ten <span class="token punctuation">(</span><span class="token keyword">char</span> c<span class="token punctuation">,</span> <span class="token keyword">int</span> ms<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token operator">::</span>this_thread<span class="token operator">::</span>sleep_for <span class="token punctuation">(</span>std<span class="token operator">::</span>chrono<span class="token operator">::</span><span class="token function">milliseconds</span><span class="token punctuation">(</span>ms<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> c<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> main <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"with launch::async: "</span><span class="token punctuation">;</span>
  std<span class="token operator">::</span>future<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">&gt;</span> foo <span class="token operator">=</span> std<span class="token operator">::</span>async <span class="token punctuation">(</span>std<span class="token operator">::</span>launch<span class="token operator">::</span>async<span class="token punctuation">,</span>print_ten<span class="token punctuation">,</span><span class="token string">'*'</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  std<span class="token operator">::</span>future<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">&gt;</span> bar <span class="token operator">=</span> std<span class="token operator">::</span>async <span class="token punctuation">(</span>std<span class="token operator">::</span>launch<span class="token operator">::</span>async<span class="token punctuation">,</span>print_ten<span class="token punctuation">,</span><span class="token string">'@'</span><span class="token punctuation">,</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// async "get" (wait for foo and bar to be ready):</span>
  foo<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> bar<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"\n\n"</span><span class="token punctuation">;</span>

  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"with launch::deferred: "</span><span class="token punctuation">;</span>
  foo <span class="token operator">=</span> std<span class="token operator">::</span>async <span class="token punctuation">(</span>std<span class="token operator">::</span>launch<span class="token operator">::</span>deferred<span class="token punctuation">,</span>print_ten<span class="token punctuation">,</span><span class="token string">'*'</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  bar <span class="token operator">=</span> std<span class="token operator">::</span>async <span class="token punctuation">(</span>std<span class="token operator">::</span>launch<span class="token operator">::</span>deferred<span class="token punctuation">,</span>print_ten<span class="token punctuation">,</span><span class="token string">'@'</span><span class="token punctuation">,</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// deferred "get" (perform the actual calls):</span>
  foo<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> bar<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

possible output<span class="token operator">:</span>
with launch<span class="token operator">::</span>async<span class="token operator">:</span> <span class="token operator">*</span><span class="token operator">*</span>@<span class="token operator">*</span><span class="token operator">*</span>@<span class="token operator">*</span><span class="token operator">*</span>@<span class="token operator">*</span>@<span class="token operator">*</span><span class="token operator">*</span>@<span class="token operator">*</span>@@@@@

with launch<span class="token operator">::</span>deferred<span class="token operator">:</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>@@@@@@@@@@</code></pre>

<h2 id="toc_11"><a name="threads"></a> 5. Threads <a href="https://people.cs.pitt.edu/~xianeizhang/notes/Concurrency.html#top">↑top</a></h2>

<h3 id="toc_12">(i) class std::thread</h3>

<p>the class thread represents a single thread of execution. Threads allow multi pieces of code to run asynchronously and simultaneously. </p>

<p>Constructors:</p>

<ul>
<li><strong><code>thread()</code></strong>: createa a new thread obj which does not represent a thread;</li>
<li><strong><code>thread(thread&amp;&amp; other)</code></strong>: move cstr. Constructs the thread obj to represent the thread of execution that was represented by other. After this call other no longer represents a thread of execution;</li>
<li><strong><code>thread(Function&amp;&amp; f, Args&amp;&amp;... args)</code></strong>: creates a new <code>std::thread</code> obj and associates it with a thread of execution. First the cstr copies/moves all arguments (both the func obj f and all args ...) to thread-accessible storage;</li>
<li><strong><code>thread(const thread&amp;)=delete</code></strong>: the copy cstr is deleted; threads are not copyable. No two <code>std::thread</code> objs may represent the same thread of execution.</li>
</ul>

<pre class=" language-cpp"><code class=" language-cpp"><span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>

<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span>thread t1<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//t1 is not a thread</span>
    std<span class="token operator">::</span>thread <span class="token function">t2</span><span class="token punctuation">(</span>f1<span class="token punctuation">,</span> n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//pass by value</span>
    std<span class="token operator">::</span>thread <span class="token function">t3</span><span class="token punctuation">(</span>f2<span class="token punctuation">,</span> std<span class="token operator">::</span><span class="token function">ref</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//pass by ref</span>
    std<span class="token operator">::</span>thread <span class="token function">t4</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>t3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//t4 is now running f2()</span>
                                    <span class="token comment" spellcheck="true">//t3 is no longer a thread</span>
    t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    t4<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>

<p>Observers:  </p>

<ul>
<li><p><strong><code>joinable</code></strong>: checks if the thread obj identifies an active thread of execution. Specially, returns <code>true</code> if <code>get_id() != std::thread:id()</code>. So, a default constructed thread is not joinable.<br>
A thread that has finished executing code, but has not yet been joined is still considered an active thread of execution and is therefore joinable.</p>

<pre class=" language-cpp"><code class=" language-cpp"><span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
std<span class="token operator">::</span>this_thread<span class="token operator">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>std<span class="token operator">::</span>chrono<span class="token operator">::</span><span class="token function">seconds</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token operator">::</span>thread t<span class="token punctuation">;</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"before starting, joinable: "</span> <span class="token operator">&lt;&lt;</span> t<span class="token punctuation">.</span><span class="token function">joinable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>

    t <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">thread</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"after starting, joinable: "</span> <span class="token operator">&lt;&lt;</span> t<span class="token punctuation">.</span><span class="token function">joinable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>

    t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"after joining, joinable: "</span> <span class="token operator">&lt;&lt;</span> t<span class="token punctuation">.</span><span class="token function">joinable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>output<span class="token operator">:</span> <span class="token number">0</span> <span class="token number">1</span> <span class="token number">0</span></code></pre></li>
<li><p><strong><code>get_id</code></strong>: returns a value of <code>std::thread::id</code> identifying the thread associated with <code>*this</code>;</p></li>
<li><p><strong><code>native_handle</code></strong>: returns the impl defined underlying thread handle;</p></li>
<li><p><strong><code>hardware_concurrency</code></strong>: returns the #concurrent threads supported by the impl. The value should be considered only a hint.</p></li>
</ul>

<p>Operations:  </p>

<ul>
<li><strong><code>join</code></strong>: blocks the current thread until the thread identified by <code>*this</code> finishes its execution;</li>
<li><strong><code>detach</code></strong>: separates the thread of executioin from the thread object, allowing execution to continue independently. Any allocated resources will be freed once the thread exits;</li>
<li><strong><code>swap(thread&amp; other)</code></strong>: exchanges the underlying handles of two thread objects.</li>
</ul>

<h3 id="toc_13">(ii) namespace this_thread</h3>

<p>For any thread, including the main thread, <code>&lt;thread&gt;</code> declares namespace <code>std::this_thread</code>, which provides the thread_specific global funcs:</p>

<ul>
<li><strong><code>get_id()</code></strong>: return the id of the current thread;</li>
<li><strong><code>sleep_for(dur)</code></strong>: blocks the execution of the current thread for <u>at least</u> the specified duration;</li>
<li><strong><code>sleep_until(tim)</code></strong>: blocks the execution of the current thread until specified sleep_time has been reached.</li>
<li><strong><code>yield()</code></strong>: provides a hint to the imple to reschedule the execution of threads, allowing other threads to run. </li>
</ul>

<h3 id="toc_14">(iii) basic usage</h3>

<p>to start a thread, we simply have to declare an obj of class <strong><code>std::thread</code></strong> and pass the desired task as initial argument, and then either wait for its end or detach it:</p>

<pre class=" language-cpp"><code class=" language-cpp"><span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

std<span class="token operator">::</span>thread <span class="token function">t</span><span class="token punctuation">(</span>doSomething<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//start doSomething() in the background</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">//wait for t to finish (block until doSomething() ends)</span></code></pre>

<p>As for <code>async()</code>, we can pass anything that's a callable object (function, member func, func obj, lambda) together with psbl additional arguments. Unless you really you what you are doing, you should pass all objs necessary to process the passed functionality <strong>by value</strong> so that the thread uses only local copies.</p>

<pre class=" language-cpp"><code class=" language-cpp"><span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">,</span> <span class="token keyword">char</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//any uncaught exception would cause the prog to terminate</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">//make sure no exception leaves the thread and terminates the program</span>
    <span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token keyword">const</span> exception<span class="token operator">&amp;</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cerr <span class="token operator">&lt;&lt;</span> <span class="token string">"thread-exception (thread "</span> 
             <span class="token operator">&lt;&lt;</span> this_thread<span class="token operator">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"): "</span> <span class="token operator">&lt;&lt;</span> e<span class="token punctuation">.</span>what <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cerr <span class="token operator">&lt;&lt;</span> <span class="token string">"thread-exception (thread "</span>
             <span class="token operator">&lt;&lt;</span> this_thread<span class="token operator">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">")"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//creating a thread might throw a std::system_error</span>
    <span class="token keyword">try</span><span class="token punctuation">{</span>
        thread <span class="token function">t1</span><span class="token punctuation">(</span>doSomething<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//print 5 dots in separate thread</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"- started fg thread "</span> <span class="token operator">&lt;&lt;</span> t1<span class="token punctuation">.</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
        
        <span class="token comment" spellcheck="true">//print other chars in other bg threads</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">5</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            thread <span class="token function">t</span><span class="token punctuation">(</span>doSomething<span class="token punctuation">,</span> <span class="token number">10</span> <span class="token string">'a'</span><span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//print 10 chars in separate thread</span>
            cout <span class="token operator">&lt;&lt;</span> <span class="token string">"- detach started bg thread "</span> <span class="token operator">&lt;&lt;</span> t<span class="token punctuation">.</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
            t<span class="token punctuation">.</span><span class="token function">detach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment" spellcheck="true">//detach thread into the bg</span>
        <span class="token punctuation">}</span>
        
        cin<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  wait <span class="token keyword">for</span> any input <span class="token punctuation">(</span><span class="token keyword">return</span><span class="token punctuation">)</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"- join fg thread "</span> <span class="token operator">&lt;&lt;</span> t1<span class="token punctuation">.</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
        t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                      <span class="token comment" spellcheck="true">//wait for t1 to finish</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token keyword">const</span> exception<span class="token operator">&amp;</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        cerr <span class="token operator">&lt;&lt;</span> <span class="token string">"exception: "</span> <span class="token operator">&lt;&lt;</span> e<span class="token punctuation">.</span><span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>

<p>Detached threads can easily become a problem if they use nonlocal resources. Passing variables and objs to a thread by ref is always a risk, and passing by value is strongly recommended.</p>

<p>And, the lifetime problem also applies to global and static objs, because when the program exits, the detached thread might still run, which means that it might access global or static obj that are already destroyed or under construction. Thus, we should ensure that these global/static objs are not destroyed before all detached threads accessing them are finished. Approaches can be:</p>

<ul>
<li>use <strong>condition variables</strong>, which the detached threads use to signal that they have finished. Before leaving main() or calling exit(), you'd have to set these condition variables then to signal that a destruction is psbl;</li>
<li>end the program by calling <strong><code>quick_exit()</code></strong>, which is to end a program without calling the dstrs for global and static objs.</li>
</ul>

<p>Because <code>std::cin</code>, <code>std::cout</code> and <code>std::cerr</code> and the other global stream objs are not destroyed during program execution, access to these objs in detached threads should introduce no undefined behavior. However, other problems, such as interleaved chars, might occur.</p>

<p>The only safe way to terminate a detached thread is with one of the "...at<em>thread</em>exit()" functions, which force the main thread to wait for the detached thread to truly finish. </p>

<p><strong>thread IDs</strong><br>
This ID is a special type std::thread::id, which is guaranteed to be unique for each thread. Threads IDs can be obtained by the thread obj or inside a threas using namespace <code>this_thread</code>.</p>

<pre class=" language-cpp"><code class=" language-cpp">std<span class="token operator">::</span>thread <span class="token function">t1</span><span class="token punctuation">(</span>doSomething<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>thread <span class="token function">t2</span><span class="token punctuation">(</span>doSomething<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token string">'+'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>thread <span class="token function">t3</span><span class="token punctuation">(</span>doSomething<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token string">'*'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"t3 ID:    "</span> <span class="token operator">&lt;&lt;</span> t3<span class="token punctuation">.</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"main ID:  "</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>this_thread<span class="token operator">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"nothread ID: "</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>thread<span class="token operator">::</span><span class="token function">id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span></code></pre>

<p>The only operations allowed for thread IDs are comparisons and calling the output operator for a stream. We cannot make any further assumptions, such as "no thread" has ID 0 or the main thread has ID 1.</p>

<pre class=" language-cpp"><code class=" language-cpp">std<span class="token operator">::</span>thread<span class="token operator">::</span>id masterThreadID<span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>std<span class="token operator">::</span>this_thread<span class="token operator">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> masterThreadID<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

std<span class="token operator">::</span>thread <span class="token function">master</span><span class="token punctuation">(</span>doSomething<span class="token punctuation">)</span><span class="token punctuation">;</span>
masterThreadID <span class="token operator">=</span> master<span class="token punctuation">.</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
std<span class="token operator">::</span>thread <span class="token function">slave</span><span class="token punctuation">(</span>doSomething<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></code></pre>

<h2 id="toc_15"><a name="prob"></a> 6. Concurrency problem <a href="https://people.cs.pitt.edu/~xianeizhang/notes/Concurrency.html#top">↑top</a></h2>

<p>Each compiler can optimize code as long as the behavior of the program visible from the outside behaves the same (<strong>as-if rule</strong>). Hence, both compiler and hardware vendors can reorder the code to speed the program, as long as the <u><em>observable behavior</em></u> remains stable. E.g., compilers might unroll loops, reorder statemenets, eliminate dead code, prefetch data, and in modern architecture, a hardware buffer might reorder loads or stores, etc.</p>

<h3 id="toc_16">(i) problems</h3>

<p>To give compilers and hardware enough freedom to optimize code, C++ does NOT in general give a couple of guarantees, which might cost too much in performance. In C++, we might have the following problems:</p>

<ul>
<li><p><strong>Unsynchronized data access</strong>: when two threads running in parallel read and write the same data, it is open which statement comes first.</p></li>
<li><p><strong>Half-written data</strong>: when one thread reads data, which another thread modifies, the reading thread might even read the data in the middle of the write of the other thread, thus reading neither the old nor the new value.</p></li>
<li><p><strong>Reordered statements</strong>: statements and operations might be reordered so that <u>the behavior of each single thread is correct</u>, but in combination of all threads, expected behavior is broken.</p>

<pre class=" language-cpp"><code class=" language-cpp"><span class="token comment" spellcheck="true">//ORIG CODE                |   //GENERATED CODE</span>
<span class="token comment" spellcheck="true">//- providing thread       |   //- consuming thread</span>
<span class="token keyword">long</span> data<span class="token punctuation">;</span>                 <span class="token operator">|</span>   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>readyFlag<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//loop until data is ready</span>
<span class="token keyword">bool</span> readyFlag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token operator">|</span>       <span class="token punctuation">;</span>
                           <span class="token operator">|</span>    <span class="token punctuation">}</span>
data <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>                 <span class="token operator">|</span>   <span class="token function">foo</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
readyFlag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>          <span class="token operator">|</span>
                           <span class="token operator">|</span>
<span class="token comment" spellcheck="true">//PSBL CODE                |</span>
<span class="token comment" spellcheck="true">//- providing thread       |   //- consuming thread</span>
<span class="token keyword">long</span> data<span class="token punctuation">;</span>                 <span class="token operator">|</span>   <span class="token function">foo</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">bool</span> readyFlag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token operator">|</span>   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>readyFlag<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//loop until data is ready</span>
                           <span class="token operator">|</span>        <span class="token punctuation">;</span>
readyFlag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>          <span class="token operator">|</span>   <span class="token punctuation">}</span>
data <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>                 <span class="token operator">|</span></code></pre></li>
</ul>

<h3 id="toc_17">(ii) Features to solve the problems</h3>

<p>To solve the three major problems of concurrent data access, we need the following concepts:</p>

<ul>
<li><strong>Atomicity</strong>: read or write access to a variable or to a sequence of statements happens <u>exclusively and without any interruption</u>, so that one thread can't read intermediate states caused by another thread.</li>
<li><strong>Order</strong>: guarantee the order of specific statements or of a group of specific statements.</li>
</ul>

<p>C++ standard library provides different ways (from high-level to low-level) to deal with the concepts:</p>

<ul>
<li><strong>future-promise</strong>: the pair guarantee both atomoticity and order; setting the <em>outcome</em> (return value or exception) of a <em>shared state</em> is guaranteed to happen before the processing of the outcome, which implies that read and write access does not happen concurrently.</li>
<li><strong>mutex</strong>es and <strong>lock</strong>s: grant exclusive access to <u><em>critical sections</em></u> or <em>protected zones</em>. However, if two threads use locked access to data, the order in which they access it may change from run to run.</li>
<li><strong>condition variables</strong>: efficiently allow one thread to wait for some predicate controlled by another thread to become true. This helps to deal with the order of multi threads by allowing one or more threads to process data or a status provided by one or more other threads.</li>
<li><strong>low-level interface of atomic data types</strong>: allow to relax the order of atomic statements or to use manual barriers for memory access. </li>
</ul>

<h2 id="toc_18"><a name="mut-lock"></a> 7. Mutexes and locks <a href="https://people.cs.pitt.edu/~xianeizhang/notes/Concurrency.html#top">↑top</a></h2>

<h3 id="toc_19">(i) std::mutex</h3>

<p>A <strong>mutex</strong>, or <em>mutual exclusion</em>, is a synchronization primitive that can be used to protect data from being simultaneously accessed by multi threads. mutex offers <u>exclusive</u>, non-recursive ownership semantics.</p>

<pre class=" language-cpp"><code class=" language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;chrono&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;mutex&gt;</span></span>
 
<span class="token keyword">int</span> g_num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// protected by g_num_mutex</span>
std<span class="token operator">::</span>mutex g_num_mutex<span class="token punctuation">;</span>
 
<span class="token keyword">void</span> <span class="token function">slow_increment</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        g_num_mutex<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">++</span>g_num<span class="token punctuation">;</span>
        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> id <span class="token operator">&lt;&lt;</span> <span class="token string">" =&gt; "</span> <span class="token operator">&lt;&lt;</span> g_num <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
        g_num_mutex<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
        std<span class="token operator">::</span>this_thread<span class="token operator">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>std<span class="token operator">::</span>chrono<span class="token operator">::</span><span class="token function">seconds</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token operator">::</span>thread <span class="token function">t1</span><span class="token punctuation">(</span>slow_increment<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span>thread <span class="token function">t2</span><span class="token punctuation">(</span>slow_increment<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>

<p>This simple <code>lock-unlock</code> approach can, however, become pretty complicated. E.g., we should ensure that an exception, which ends an exclusive access, also unlocks the crspding mutex; ow, a rsc might become locked forever. Also, deadlock scenarios are psbl, with two thread waiting for a lock of the other thread before freeing their own lock.</p>

<p>To deal with exceptions (guarnatee <strong>exception safety</strong>), we shoud not lock and unlock by ourselves; instead, we should use the <strong>RAII</strong> principle (Resource Acquisition Is Initialization), whereby the cstr acquires a rsc so that the dstr, which is always called even when an exception causes the end of the lifetime, releases rsc automatically.</p>

<h3 id="toc_20">(ii) std::lock_guard</h3>

<p><code>std::mutex</code> is usually not accessed directly: <code>std::unique_lock</code> and <code>std::lock_guard</code> are used to manage locking in <strong>exception-safe manner</strong>.
Note that the locks should be limited to the shortest period psbl because they block other code from running in parallel.</p>

<pre class=" language-cpp"><code class=" language-cpp">std<span class="token operator">::</span>map<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token punctuation">,</span> std<span class="token operator">::</span>string<span class="token operator">&gt;</span> g_pages<span class="token punctuation">;</span>
std<span class="token operator">::</span>mutex g_pages_mutex<span class="token punctuation">;</span>
 
<span class="token keyword">void</span> <span class="token function">save_page</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span>url<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// simulate a long page fetch</span>
    std<span class="token operator">::</span>this_thread<span class="token operator">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>std<span class="token operator">::</span>chrono<span class="token operator">::</span><span class="token function">seconds</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span>string result <span class="token operator">=</span> <span class="token string">"fake content"</span><span class="token punctuation">;</span>
 
    std<span class="token operator">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">guard</span><span class="token punctuation">(</span>g_pages_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    g_pages<span class="token punctuation">[</span>url<span class="token punctuation">]</span> <span class="token operator">=</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token comment" spellcheck="true">//lock released here</span>
 
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token operator">::</span>thread <span class="token function">t1</span><span class="token punctuation">(</span>save_page<span class="token punctuation">,</span> <span class="token string">"http://foo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span>thread <span class="token function">t2</span><span class="token punctuation">(</span>save_page<span class="token punctuation">,</span> <span class="token string">"http://bar"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
    <span class="token comment" spellcheck="true">// safe to access g_pages without lock now, as the threads are joined</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span> <span class="token operator">&amp;</span>pair <span class="token operator">:</span> g_pages<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> pair<span class="token punctuation">.</span>first <span class="token operator">&lt;&lt;</span> <span class="token string">" =&gt; "</span> <span class="token operator">&lt;&lt;</span> pair<span class="token punctuation">.</span>second <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>

<h4 id="toc_21">recursive locks</h4>

<p>Sometimes, the ability to lock recursively is required. Typical examples are active objs or monitors, which contain a mutex and take lock inside every public method to protect data races corrupting the internal state of the obj. E.g., a db interface might look as follows:</p>

<pre class=" language-cpp"><code class=" language-cpp"><span class="token keyword">class</span> <span class="token class-name">DatabaseAccess</span> <span class="token punctuation">{</span>
 <span class="token keyword">private</span><span class="token operator">:</span>
    std<span class="token operator">::</span>mutex dbMutex<span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment" spellcheck="true">//state of database access</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> createTable <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        std<span class="token operator">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lg</span><span class="token punctuation">(</span>dbMutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">void</span> insertData <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        std<span class="token operator">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lg</span><span class="token punctuation">(</span>dbMutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>

<p>When we introduce a public member func that might call other public member funcs, this can become complicated:</p>

<pre class=" language-cpp"><code class=" language-cpp"><span class="token keyword">void</span> createTableAndInsertData <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token operator">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lg</span><span class="token punctuation">(</span>dbMutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">createTable</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//ERROR: deadlock because dbMutex is locked again</span>
<span class="token punctuation">}</span></code></pre>

<p>Calling <code>createTableAndInsertData()</code> will result in a deadlock because after locking <code>dbMutex</code>, the call of <code>createTable()</code> will try to lock <code>dbMutex</code> again, which will block until the lock of <code>dbMutex</code> is available, which will never happen because <code>createTableAndInsertData()</code> will block until <code>createTable()</code> is done. </p>

<p>A <strong>recursive mutex</strong> is a lockable object, just like <em>mutex</em>, but allows the same thread to acquire multi levels of ownership over the mutex obj. The lock is released when the last crspding <code>unlock()</code> is called.</p>

<pre class=" language-cpp"><code class=" language-cpp"><span class="token keyword">class</span> <span class="token class-name">DatabaseAccess</span> <span class="token punctuation">{</span>
 <span class="token keyword">private</span><span class="token operator">:</span>
    std<span class="token operator">::</span>recursive_mutex dbMutex<span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment" spellcheck="true">//state of database access</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> createTable <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        std<span class="token operator">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token operator">::</span>recursive_mutex<span class="token operator">&gt;</span> <span class="token function">lg</span><span class="token punctuation">(</span>dbMutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">void</span> insertData <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        std<span class="token operator">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token operator">::</span>recursive_mutex<span class="token operator">&gt;</span> <span class="token function">lg</span><span class="token punctuation">(</span>dbMutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">void</span> createTableAndInsertData <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        std<span class="token operator">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token operator">::</span>recursive_mutex<span class="token operator">&gt;</span> <span class="token function">lg</span><span class="token punctuation">(</span>dbMutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token function">createTable</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//OK: no deadlock</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>

<h4 id="toc_22">tried and timed locks</h4>

<p>sometimes a program wants to acquire a lock but doesn't want to block (forever) if this is not psbl. For this case, mutexes provide a <code>try_block()</code> member func that <em>tries</em> to acquire a lock. </p>

<pre class=" language-cpp"><code class=" language-cpp">std<span class="token operator">::</span>mutex m<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//try to acquire a lock and do other stuff if not psbl</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>m<span class="token punctuation">.</span><span class="token function">try_lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">doSomeOtherStuff</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
std<span class="token operator">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lb</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> std<span class="token operator">::</span>adopt_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></code></pre>

<p>To wait only for a particular amount of time, we can use a timed mutex, <code>try_lock_for()</code> and <code>try_lock_until</code> provided in <code>std::timed_mutex</code> and <code>std::recursive_timed_mutex</code>, respectively.</p>

<pre class=" language-cpp"><code class=" language-cpp">std<span class="token operator">::</span>timed_mutex m<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//try for 1sec to acquire a lock</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>m<span class="token punctuation">.</span><span class="token function">try_lock_for</span><span class="token punctuation">(</span>std<span class="token operator">::</span>chrono<span class="token operator">::</span><span class="token function">seconds</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token operator">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token operator">::</span>timed_mutex<span class="token operator">&gt;</span> <span class="token function">lg</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> std<span class="token operator">::</span>adopt_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token function">couldNotGetTheLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>

<h4 id="toc_23">mutex constants</h4>

<p>Mutex constants are used as tag argument for <code>unique_lock</code> to select a specific constructor: </p>

<ul>
<li><strong>adopt_lock</strong>: <code>unique_lock</code> objs constructed with <code>adopt_block</code> do not lock the mutex obj on construction, assuming instead that it is already locked by the current thread, and thus just adopts the ownership of the existing lock on the mutex rather than attempt to lock the mutex in the cstr.</li>
<li><strong>defer_lock</strong>: <code>unique_lock</code> objs constructed with <code>defer_lock</code> do not lock the mutex obj automatically on construction, initializing them as not owning a lock. And later, the lock can be acquired by passing the <code>std::unique_lock</code> obj itself to <code>std::lock</code>.</li>
<li><strong><code>try_to_lock</code></strong>: <code>unique_lock</code> objs constructed with <code>try_to_lock</code> attempt to lock the mutex obj by calling its <code>try_lock</code> member instead of its <code>lock</code> member.</li>
</ul>

<h4 id="toc_24">dealing with multiple locks</h4>

<p>C++ enables to lock multi mutexes, avoiding deadlock: <code>std::lock()</code> locks all mutexes passed as arguments, blocking until all mutexes are locked or until an exception is thrown. In the latter case, it unlocks mutexes already successfully locked.</p>

<pre class=" language-cpp"><code class=" language-cpp">std<span class="token operator">::</span>mutex m1<span class="token punctuation">,</span> m2<span class="token punctuation">;</span>

<span class="token keyword">int</span> idx <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">try_lock</span><span class="token punctuation">(</span>m1<span class="token punctuation">,</span> m2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//try to lock both mutexes</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>idx <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">//both locks succeeded</span>
    std<span class="token operator">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lockM1</span><span class="token punctuation">(</span>m1<span class="token punctuation">,</span> std<span class="token operator">::</span>adopt_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lockM1</span><span class="token punctuation">(</span>m2<span class="token punctuation">,</span> std<span class="token operator">::</span>adopt_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span> <span class="token comment" spellcheck="true">/*auto unlock all mutexes*/</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//idx has zero-based index of first failed lock</span>
    cerr <span class="token operator">&lt;&lt;</span> <span class="token string">"could not lock mutex m"</span> <span class="token operator">&lt;&lt;</span> idx<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>

<h3 id="toc_25">(iii) class <code>unique_lock</code></h3>

<p>Besides class <code>lock_guard&lt;&gt;</code>, C++ standard library provides class <code>unique_lock&lt;&gt;</code>, which is lot more flexible when dealing with locks for mutexes. It allows <u>deferred locking</u>, <u>time-constrained attempts at locking</u>, <u>recursive locking</u>, <u>transfer of lock ownership</u>, and <u>use with condition variables</u>.</p>

<ul>
<li><code>std::lock_guard</code> keeps its associated mutex locked during the <u>entire life time</u> by acquiring the lock on construction and releasing the lock on destruction. </li>
<li><code>std::unique_lock</code> is a lot more flexible when dealing with mutex locks. It has the same interface as <code>std::lock_guard</code> but provide extra abilities to program explicitly when and how to lock or unlock its mutex. Thus, this lock obj may or may not have a mutex locked (also known as <em>owning</em> a mutex).</li>
<li>the ownership of a <code>std::unique_lock</code> can be transferred bt instances, and hence <code>std::unique_lock</code> is <em>movable</em> whereas <code>std::lock_guard</code> is not.</li>
</ul>

<pre class=" language-cpp"><code class=" language-cpp">std<span class="token operator">::</span>mutex Mutex<span class="token punctuation">;</span>

std<span class="token operator">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token operator">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lock</span><span class="token punctuation">(</span>Mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> lock<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// mutex isn't unlocked here!</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">Bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">auto</span> lock <span class="token operator">=</span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>   <span class="token comment" spellcheck="true">// mutex is unlocked when lock goes out of scope</span></code></pre>

<p>Member functions:</p>

<ul>
<li><p><strong><code>lock()</code></strong>: locks the associated mutes;</p>

<pre class=" language-cpp"><code class=" language-cpp"><span class="token keyword">int</span> counter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>mutex counter_mutex<span class="token punctuation">;</span>
std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>thread<span class="token operator">&gt;</span> threads<span class="token punctuation">;</span>

<span class="token keyword">auto</span> worker_task <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token operator">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lock</span><span class="token punctuation">(</span>counter_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">++</span>counter<span class="token punctuation">;</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> id <span class="token operator">&lt;&lt;</span> <span class="token string">", initial counter: "</span> <span class="token operator">&lt;&lt;</span> counter <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
    lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// don't hold the lock while we simulate an expensive operation</span>
    std<span class="token operator">::</span>this_thread<span class="token operator">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>std<span class="token operator">::</span>chrono<span class="token operator">::</span><span class="token function">seconds</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">++</span>counter<span class="token punctuation">;</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> id <span class="token operator">&lt;&lt;</span> <span class="token string">", final counter: "</span> <span class="token operator">&lt;&lt;</span> counter <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> threads<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>worker_task<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>thread <span class="token operator">:</span> threads<span class="token punctuation">)</span> thread<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li>
<li><p><strong><code>try_lock()</code></strong>: tries to lock the associated mutex, returns if the mutex is not available.</p></li>
<li><p><strong><code>try_lock_for</code></strong>: tries to lock the associated mutex. Returns if the mutex has been unavailable for the specified time duration. </p></li>
<li><p><strong><code>try_lock_until</code></strong>: tries to lock the associated mutex, returns if the mutex has been unavailable until specified time point has been reached.</p></li>
<li><p><strong><code>unlock</code></strong>: unlocks the associated mutex.</p></li>
<li><p><strong><code>swap</code></strong>: swaps state with another <code>std::unique_lock</code>.</p></li>
<li><p><strong><code>release</code></strong>: disassociates the associated mutex without unlocking it.</p></li>
<li><p><strong><code>mutex()</code></strong>: returns a ptr to the associated mutex.</p></li>
<li><p><strong><code>owns_lock</code></strong> or <strong><code>operator bool</code></strong>: tests whether the lock owns its associated mutex.</p></li>
</ul>

<h3 id="toc_26">(iv) calling once for multi threads</h3>

<p>Sometimes multi threads might not need some functionality that should get processed whenever the first thread needs it. A typical example is lazy initialization: the first time one of the threads needs sth that has to get processed, you process it (but not before, because u want to save the time to process it if it is not needed).</p>

<p>For single-thread environment:</p>

<pre class=" language-cpp"><code class=" language-cpp"><span class="token keyword">static</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">&gt;</span> staticData<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>staticData<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        staticData <span class="token operator">=</span> <span class="token function">initializeStaticData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span></code></pre>

<p>Such code doesn't work in multithreaded context, because of data races in checking. Instead of using mutex, we can use C++ standard library funcs <code>std::once_flag</code> and <code>std::call_once</code>:</p>

<pre class=" language-cpp"><code class=" language-cpp">std<span class="token operator">::</span>once_flag oc<span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">//global flag</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
std<span class="token operator">::</span><span class="token function">call_once</span><span class="token punctuation">(</span>os<span class="token punctuation">,</span> initialize<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//init if not inited yet</span>

<span class="token keyword">static</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">&gt;</span> staticData<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> std<span class="token operator">::</span>once_flag oc<span class="token punctuation">;</span>
    std<span class="token operator">::</span><span class="token function">call_once</span><span class="token punctuation">(</span>oc<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>
        staticData <span class="token operator">=</span> <span class="token function">initializeStaticData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span></code></pre>

<p>The 1st argument passed to <code>call_once()</code> must be the crspding <code>once_flag</code>; further arguments are the usual arguments for callable objects: func, member func, func obj, or lambda, plus optional arguments for the func called. Thus, lazy initialization of an obj used in multi-threads might as follow:</p>

<pre class=" language-cpp"><code class=" language-cpp"><span class="token keyword">class</span> <span class="token class-name">X</span> <span class="token punctuation">{</span>
 <span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">mutable</span> std<span class="token operator">::</span>once_flag initDataFlag<span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">initData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
    data <span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>
        std<span class="token operator">::</span><span class="token function">call_once</span><span class="token punctuation">(</span>initDataFlag<span class="token punctuation">,</span> <span class="token operator">&amp;</span>X<span class="token operator">::</span>initData<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>

<h2 id="toc_27"><a name="cond"></a> 8. Condition variables <a href="https://people.cs.pitt.edu/~xianeizhang/notes/Concurrency.html#top">↑top</a></h2>

<p>Sometimes, tasks performed by different threads have to wait for each other. Thus, we have to synchronize concurrent operations for other reasons than to access the same data.</p>

<p><strong>Condition variables</strong> can be used to synchronize logical dependencies in data flow bt threads. A condition variable is a variable by which a thread can wake up one or multi other waiting threads.</p>

<h3 id="toc_28">(i) steps</h3>

<p>In principle, a condition variable works as follows:</p>

<ul>
<li><p>include both <code>&lt;mutex&gt;</code> and <code>&lt;condition_variable&gt;</code> to declare a mutex and a condition variable:</p>

<pre class=" language-cpp"><code class=" language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;mutex&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;condition_variable&gt;</span></span>

std<span class="token operator">::</span>mutex readyMutex<span class="token punctuation">;</span>
std<span class="token operator">::</span>condition_variable readyCondVar<span class="token punctuation">;</span></code></pre></li>
<li><p>the thread (or one of multi threads) that signals the fulfillment of a condition has to call</p>

<pre class=" language-cpp"><code class=" language-cpp">readyCondVar<span class="token punctuation">.</span><span class="token function">notify_one</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//notify one of the waiting threads</span>
<span class="token comment" spellcheck="true">//or</span>
readyCondVar<span class="token punctuation">.</span><span class="token function">notify_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//notify all the waiting threads</span></code></pre></li>
<li><p>any thread that waits for the condition has to call</p>

<pre class=" language-cpp"><code class=" language-cpp">std<span class="token operator">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">l</span><span class="token punctuation">(</span>readyMutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
readyCondVar<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li>
</ul>

<p>Thus, the thread providing or preparing sth simply calls <code>notify_one()</code> or <code>notify_all()</code> for the cond var, which for one or all the waiting threads is the moment to wake up.</p>

<p>Cond var in general might have so-called <u><em>spurious wakeups</em></u>, i.e., a wait on a cond var may return even if the cond var has not been noified. Thus, a wakeup does not necessarily mean that the required cond now holds. Rather, after a wakeup we still need some code to verify that the cond in fact has arrived.</p>

<pre class=" language-cpp"><code class=" language-cpp"><span class="token keyword">bool</span> readyFlag<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//a flag signaling the cond is indeed satisfied</span>
std<span class="token operator">::</span>mutex readyMutex<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//a mutex</span>
std<span class="token operator">::</span>condition_variable readyCondVar<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//a cond var</span>

<span class="token comment" spellcheck="true">//locks the mutex, updates the cond, unlocks the mutex and notifies the cond var</span>
<span class="token keyword">void</span> <span class="token function">thread1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//do sth thread2 needs as preparation</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"&lt;return&gt;"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
    std<span class="token operator">::</span>cin<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment" spellcheck="true">//signal that thread1 has prepared a cond</span>
    <span class="token punctuation">{</span>
        std<span class="token operator">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lg</span><span class="token punctuation">(</span>readyMutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        readyFlag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//release lock</span>
    readyCondVar<span class="token punctuation">.</span><span class="token function">notify_one</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">thread2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//wait until thread1 is ready (readyFlag is true)</span>
    <span class="token punctuation">{</span>
        std<span class="token operator">::</span>unque_lock<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">ul</span><span class="token punctuation">(</span>readyMutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        readyCondVar<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>ul<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span> <span class="token keyword">return</span> readyFlag<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//release lock</span>
    
    <span class="token comment" spellcheck="true">//do whatever shall happen after thread1 has prepared things</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"done"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl'
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">auto</span> f1 <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">async</span><span class="token punctuation">(</span>std<span class="token operator">::</span>launch<span class="token operator">::</span>async<span class="token punctuation">,</span> thread1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span> f2 <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">async</span><span class="token punctuation">(</span>std<span class="token operator">::</span>launch<span class="token operator">::</span>async<span class="token punctuation">,</span> thread2<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span></code></pre>

<p>The waiting thread locks the mutex with a <code>unique_lock</code>, waits for the notification while checking the condition and releases the lock:</p>

<pre class=" language-cpp"><code class=" language-cpp"><span class="token punctuation">{</span>
    std<span class="token operator">::</span>unque_lock<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">ul</span><span class="token punctuation">(</span>readyMutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    readyCondVar<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>ul<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span> <span class="token keyword">return</span> readyFlag<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token comment" spellcheck="true">//release lock</span></code></pre>

<p>Here, a <code>wait()</code> member for cond vars is used as follow: pass the lock <code>ul</code> for the mutex <code>readyMutex</code> as 1st argument and a lambda as callable object double checking the cond as second argument. The effect is that <code>wait()</code> internally calls a loop until the passed callable returns true. Thus, the code has the same effect as the following code:</p>

<pre class=" language-cpp"><code class=" language-cpp"><span class="token punctuation">{</span>
    std<span class="token operator">::</span>unque_lock<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">ul</span><span class="token punctuation">(</span>readyMutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>readyFlag<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        readyCondVar<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>ul<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token comment" spellcheck="true">//release lock</span></code></pre>

<h3 id="toc_29">(ii) example of a multi-thread queue</h3>

<p>three threads push values into a quque that two other threads read and process:</p>

<pre class=" language-cpp"><code class=" language-cpp">std<span class="token operator">::</span>queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> queue<span class="token punctuation">;</span>
std<span class="token operator">::</span>mutex queueMutex<span class="token punctuation">;</span>
std<span class="token operator">::</span>condition_variable queueCondVar<span class="token punctuation">;</span>

<span class="token keyword">void</span> provider <span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//push different vals</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">6</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">{</span>
            std<span class="token operator">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lg</span><span class="token punctuation">(</span>queueMutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
            queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>val<span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//release lock</span>
        queueCondVar<span class="token punctuation">.</span><span class="token function">notify_one</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        std<span class="token operator">::</span>this_thread<span class="token operator">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>
                    std<span class="token operator">::</span>chrono<span class="token operator">::</span><span class="token function">milliseconds</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> consumer <span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//pop vals if available (num identifies the consumer)</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> val<span class="token punctuation">;</span>
        <span class="token punctuation">{</span>
            std<span class="token operator">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">ul</span><span class="token punctuation">(</span>queueMutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
            queueCondVar<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>ul<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            val <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            queue<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//release lock</span>
        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"consumer "</span> <span class="token operator">&lt;&lt;</span> num <span class="token operator">&lt;&lt;</span> <span class="token string">": "</span> <span class="token operator">&lt;&lt;</span> val <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//start three providers for values 100+, 300+, 500+</span>
    <span class="token keyword">auto</span> p1 <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">async</span><span class="token punctuation">(</span>std<span class="token operator">::</span>launch<span class="token operator">::</span>async<span class="token punctuation">,</span> provider<span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span> p2 <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">async</span><span class="token punctuation">(</span>std<span class="token operator">::</span>launch<span class="token operator">::</span>async<span class="token punctuation">,</span> provider<span class="token punctuation">,</span> <span class="token number">300</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span> p3 <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">async</span><span class="token punctuation">(</span>std<span class="token operator">::</span>launch<span class="token operator">::</span>async<span class="token punctuation">,</span> provider<span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">//start two consumers printing the vals</span>
    <span class="token keyword">auto</span> c1 <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">async</span><span class="token punctuation">(</span>std<span class="token operator">::</span>launch<span class="token operator">::</span>async<span class="token punctuation">,</span> consumer<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span> c2 <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">async</span><span class="token punctuation">(</span>std<span class="token operator">::</span>launch<span class="token operator">::</span>async<span class="token punctuation">,</span> consumer<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>

<h2 id="toc_30"><a name="atomics"></a> 9. Atomics <a href="https://people.cs.pitt.edu/~xianeizhang/notes/Concurrency.html#top">↑top</a></h2>

<p>Once a <code>std::atomic&lt;T&gt;</code> object has been constructed, operations on it behave as if they were inside a mutex-protected critical section, but the operations are generally implemented using <u>special machine instructions</u> that are more efficient than would be the case if a mutex were employed.</p>

<pre class=" language-cpp"><code class=" language-cpp">std<span class="token operator">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">ai</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//initialize ai to 0</span>
ai <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//atomically set ai to 10</span>
std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> ai<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//atomically read ai's value</span>
<span class="token operator">++</span>ai<span class="token punctuation">;</span>                       <span class="token comment" spellcheck="true">//atomically increment ai to 11</span>
<span class="token operator">--</span>ai<span class="token punctuation">;</span>                       <span class="token comment" spellcheck="true">//atomically decrement ai to 10</span></code></pre>

<p>During execution of these statements, other therads reading <code>ai</code> may see only values of <code>0</code>, <code>10</code> or <code>11</code>. No other values are psbl.</p>

<h3 id="toc_31">(i) examples of using atomics</h3>

<p>using lock:</p>

<pre class=" language-cpp"><code class=" language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;mutex&gt;</span></span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
   
<span class="token keyword">bool</span> readyFlag<span class="token punctuation">;</span>
std<span class="token operator">::</span>mutex readyFlagMutex<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">thread1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// do something thread2 needs as preparation</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    std<span class="token operator">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lg</span><span class="token punctuation">(</span>readyFlagMutex<span class="token punctuation">)</span><span class="token punctuation">;</span> 
    readyFlag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">thread2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// wait until readyFlag is true (thread1 is done) </span>
    <span class="token punctuation">{</span>
        std<span class="token operator">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">ul</span><span class="token punctuation">(</span>readyFlagMutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>readyFlag<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            ul<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            std<span class="token operator">::</span>this_thread<span class="token operator">::</span><span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// hint to reschedule to the next thread </span>
            std<span class="token operator">::</span>this_thread<span class="token operator">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>std<span class="token operator">::</span>chrono<span class="token operator">::</span><span class="token function">milliseconds</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
            ul<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// release lock</span>

    <span class="token comment" spellcheck="true">// do whatever shall happen after thread1 has prepared things</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span></code></pre>

<p>using atomic:</p>

<pre class=" language-cpp"><code class=" language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;atomic&gt;</span> </span><span class="token comment" spellcheck="true">// for atomic types ...</span>

std<span class="token operator">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">&gt;</span> <span class="token function">readyFlag</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">thread1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// do something thread2 needs as preparation ...</span>
    readyFlag<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">thread2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// wait until readyFlag is true (thread1 is done) </span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>readyFlag<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        std<span class="token operator">::</span>this_thread<span class="token operator">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>std<span class="token operator">::</span>chrono<span class="token operator">::</span><span class="token function">milliseconds</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// do whatever shall happen after thread1 has prepared things</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span></code></pre>

<h3 id="toc_32">(ii) operations</h3>

<ul>
<li><strong><code>load()</code></strong>: performs a so-called <strong>acquire</strong> operation on the affected mem loc, which by default ensures that all <u>following</u> mem operations, whether atomic or not, become visible to other threads <u>after</u> the load operation.</li>
<li><strong><code>store()</code></strong>: performs a so-called <strong>release</strong> operation on the affected mem loc, which by default ensures that all <u>prior</u> mem operations, whether atomic or not, become visible to other threads <u>before</u> the effect of the store operation.</li>
</ul>

<pre class=" language-cpp"><code class=" language-cpp"><span class="token keyword">long</span> data<span class="token punctuation">;</span>
std<span class="token operator">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">&gt;</span> <span class="token function">readyFlag</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">provider</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//after reading a char</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"&lt;return&gt;"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
    std<span class="token operator">::</span>cin<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment" spellcheck="true">//provide some data</span>
    data <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//add signal readiness</span>
    readyFlag<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">consumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//wait for readiness and do sth else</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>readyFlag<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        std<span class="token operator">::</span>cout<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        std<span class="token operator">:</span><span class="token punctuation">;</span>this_thread<span class="token operator">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>std<span class="token operator">::</span>chrono<span class="token operator">::</span><span class="token function">milliseconds</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment" spellcheck="true">//and process provided data</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"\nvalue : "</span> <span class="token operator">&lt;&lt;</span> data <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>

<p>Because the setting of data <em>happens before</em> the <code>provider()</code> stores true in the <code>readyFlag</code> and the processing of data <em>happens after</em> the <code>consumer()</code> has loaded true as value of the <code>readyFlag</code>, the processing of <code>data</code> is guaranteed to happen after the data was provided.</p>

<p>This guarantee is provided because in all atomic operations, we use a default <em>memory order</em> named <strong>memory_order_seq_cst</strong> (<em>sequential consistent memory order</em>).</p>

<h4 id="toc_33">std::atomic_flag</h4>

<p><code>std::atomic_flag</code> is a really simple Boolean flag, and operations on this type are <strong>required</strong> (the <strong>only</strong> one guaranteed to be lcok-free) to be lock-free; and, unlike <code>std::atomic&lt;bool&gt;</code>, <code>std::atomic_flag</code> does not provide load or store operations.</p>

<p>Once we have a simple lock-free Boolean flag, we can use it to implement a simple lock and thus implement all the the atomic types.</p>

<p><code>std::atomic_flag</code> is "really simple" on the following aspects:</p>

<ul>
<li>Objs of type <code>std::atomic_flag</code> can be in one of two states: <em>set</em> or <em>clear</em>;</li>
<li>objs of type <code>std::atomic_flag</code> <strong>must</strong> be inited with <code>ATOMIC_FLAG_INIT</code>, which sets the flag to <em>clear</em> state;</li>
<li>once we have the flag obj inited, there are only three things we can do with it: <em>destroy</em> it (dstr), <em>clear</em> it (<code>clear()</code>), or <em>set it and query</em> the prev value (<code>test_and_set()</code>).</li>
<li>all operations on an atomic type are defined as atomic, and asgnment and copy-construction are not permitted, because they involve two objs, which cannot be atomic for a single operation.</li>
</ul>

<pre class=" language-cpp"><code class=" language-cpp">std<span class="token operator">::</span>atomic_flag lock <span class="token operator">=</span> ATOMIC_FLAG_INIT<span class="token punctuation">;</span>
 
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> cnt <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token operator">++</span>cnt<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>lock<span class="token punctuation">.</span><span class="token function">test_and_set</span><span class="token punctuation">(</span>std<span class="token operator">::</span>memory_order_acquire<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// acquire lock</span>
             <span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// spin</span>
        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Output from thread "</span> <span class="token operator">&lt;&lt;</span> n <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
        lock<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span>std<span class="token operator">::</span>memory_order_release<span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">// release lock</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>thread<span class="token operator">&gt;</span> v<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> n <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        v<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> t <span class="token operator">:</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>

<h4 id="toc_34">other atomic types</h4>

<p>the remaining atomic types are all accessed through specializations of the <code>std::atomic&lt;&gt;</code> class template and are a bit more full-featured but may not be lock-free. On most popular platforms, it's expected that the atomic variants of all the built-in types (e.g., <code>std::atomic&lt;int&gt;</code> and <code>std::atomic&lt;void*&gt;</code>) are indeed lock-free, but it isn't required.</p>

<p>the standard atomic types are not copyable or copy-assignable, and thus have no copy cstrs or copy asgnment operators. They do, however, support asgnment from and implicit conversion to the crspding built-in types as well as direct <code>load()</code>/<code>store()</code>, <code>exchange()</code>, <code>compare_exchange_weak()</code> and <code>compare_exchange_strong()</code>. They also support compound asgnment operators where <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>|=</code>, etc.</p>

<p>Unlike most assignment operators, the assignment operators for atomic types do not return a reference to their left-hand arguments. They return a copy of the stored value instead.</p>

<ul>
<li><strong><code>is_lock_free</code></strong>: the atomic operations on the given type are done directly with atomic instructions (<code>true</code>), or done by using a lock internal to the compiler and library (<code>false</code>);</li>
</ul>

<p><strong>std::atomic<bool></bool></strong><br>
<code>std::atomic&lt;bool&gt;</code> is the most basic of the atomic integral type. </p>

<ul>
<li><strong><code>load()</code></strong>: </li>
<li><strong><code>store()</code></strong>: rather than using the restrictive <code>clear()</code> func of <code>std::atomic_flag</code>, writes of <code>std::atomic&lt;bool&gt;</code> use <code>store</code>;</li>
<li><p><strong><code>exchange(des)</code></strong>: replace <code>test_and_set</code>; <code>exchange()</code> is a read-modify-write operation, allowing to replace the stored value with a new one of your choosing and atomically retrieve the original value;</p>

<pre class=" language-cpp"><code class=" language-cpp">std<span class="token operator">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">&gt;</span> b<span class="token punctuation">;</span>
<span class="token keyword">bool</span> x <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>std<span class="token operator">::</span>memory_order_acquire<span class="token punctuation">)</span><span class="token punctuation">;</span>
b<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
x <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">exchange</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> std<span class="token operator">::</span>memory_order_acq_rel<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li>
</ul>

<p>storing a new value (or not) depending on the current value:<br>
the new operation is called compare/exchange, which compares the value of the atomic variable with a supplied expected value and stores the supplied desired value if they're equal; if the values are not equal, the expected value is updated with the actual value of the atomic variable. The return type is a bool, which is <code>true</code> if the store was performed and <code>false</code> ow.</p>

<ul>
<li><p><strong><code>compare_exchange_weak(exp, des)</code></strong>: the store might not be successful even if the orig value was equal to the expected value, in which case the value of the variable is unchanged and the return value is <code>false</code>; this is most likely happen on machines that lack a single compare-and-exchange instr.<br>
because <code>compare_exchange_weak()</code> can fail spuriously, it must typically be used in a loop:</p>

<pre class=" language-cpp"><code class=" language-cpp"><span class="token keyword">bool</span> expected <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token keyword">extern</span> atomic<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">&gt;</span> b<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//set somewhere else</span>
<span class="token comment" spellcheck="true">//keep looping as long as 'expected' is false, indicating suprious failure</span>
<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>b<span class="token punctuation">.</span><span class="token function">compare_exchange_weak</span><span class="token punctuation">(</span>expected<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>expected<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li>
<li><p><strong><code>compare_exchange_strong(exp, des)</code></strong>: is guaranteed to return <code>false</code> only if the actual value wasn't equal to the <code>expected</code> value.</p></li>
</ul>

<p><strong>std::atomic&lt;T*&gt;</strong><br>
The interface of <code>std::atomic&lt;T&gt;</code> is essentially the same with <code>std::atomic&lt;bool&gt;</code>. The new opertionss are the ptr arithmetic ones:</p>

<ul>
<li><p><strong><code>fetch_add()/fetch_sub()</code></strong>: do atomic addition and subtraction on the stored addr; <code>fetch_add()</code> is also known as <em>exchange-and-add</em>, and it's and atomic read-modify-write operation.<br>
operators <code>+=/-=/++/--</code> are convenient wrappers;<br>
if <code>x</code> is <code>std::stomic&lt;Foo*&gt;</code> to the 1st entry of an array of <code>Foo</code> objs, then <code>x+=3</code> changes it to point to the 4th entry and returns a plain <code>Foo*</code> that also points to that 4th entry; <code>fetch_add()/fetch_sub()</code> are slightly different in that they return the orig value (so <code>x.fetch_add(3)</code> will update <code>x</code> to point to the 4th value but return a ptr to the 1st value in the array).</p>

<pre class=" language-cpp"><code class=" language-cpp"><span class="token keyword">class</span> <span class="token class-name">Foo</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
Foo some_array<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>atomic<span class="token operator">&lt;</span>Foo<span class="token operator">*</span><span class="token operator">&gt;</span> <span class="token function">p</span><span class="token punctuation">(</span>some_array<span class="token punctuation">)</span><span class="token punctuation">;</span>
Foo<span class="token operator">*</span> x <span class="token operator">=</span> p<span class="token punctuation">.</span><span class="token function">fetch_add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//add 2 to p, return old value</span>
<span class="token function">assert</span><span class="token punctuation">(</span>x <span class="token operator">==</span> some_array<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">assert</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">&amp;</span>some_array<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

x<span class="token operator">=</span><span class="token punctuation">(</span>p<span class="token operator">-</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                      <span class="token comment" spellcheck="true">//subtract 1 from p, return new value</span>
<span class="token function">assert</span><span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token operator">&amp;</span>some_array<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">assert</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">&amp;</span>some_array<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li>
</ul>

<p><strong>std::atomic&lt;T&gt;</strong><br>
the remaining basic atomic types are essentially all the same: they're all atomic integral types and have the same interface as each other, except that the associated built-in type is different.</p>

<p>as well as the usual set of operations (<code>load()</code>, <code>store()</code>, <code>exchange()</code>, <code>compare_exchange_weak()</code> and <code>compare_exchange_strong()</code>), hte atomic integral types such as <code>std::atomic&lt;int&gt;</code> and <code>std::atomic&lt;unsigned long long&gt;</code> have quite a comprehensive set of operations available: <code>fetch_add()</code>, <code>fetch_sub()</code>, <code>fetch_or</code>, <code>fetch_xor</code>, compound-asgnment forms of these operations (+=, -=, &amp;=, |=, and ^=), and ++/--. Only division, multiplication, and shift operators are missing. Because atomic integral values are typically used either as counters or as bitmasks, this isn't a particularly noticeable loss; additional operations can easily be done using <code>compare_exchange_weak()</code> in a loop, if required.</p>

<h3 id="toc_35">the low-level interface of atomics</h3>

<p>the <strong>low-level interface</strong> of atomics means using the atomic operations in a way that we have no guaranteed sequential consistency. Thus, compilers and hardware might (partially) reorder access on atomics.</p>

<h4 id="toc_36">std::memory_order</h4>

<p><code>std::memory_order</code> specifies how regular, non-atomic mem accesses are to be ordered around an atomic operation. Absent any constraint on a multi-core system, when multi threads simultaneously read and write to several variables, one thread can observe the values change in an order different from the order another thread wrote them. Indeed, the apprent order of changes can even differ among multi reader threads. Some similar effects can occur even on uniprocessor systems due to compiler transformations allowed by the mem model.</p>

<p>The default behavior of all atomic operations in the library provides for <strong>sequential consistent ordering</strong>. The default can hurt performance, but the library's atomic operations can be given an additional <code>std::memory_order</code> argument to specify the exact constraints, beyond atomicity, that the compiler and processor must enforce that operation.</p>

<ul>
<li><p><strong><code>memory_order_relaxed</code></strong>: relaxed operations, there are no sync or ordering constraints, <u>only atomicity</u> is required of this operation;</p></li>
<li><p><strong><code>memory_order_consume</code></strong>: a <u>load</u> operation with this memory order performs a <em>consume operation</em> on the affected memory location: <u>no reads in the current thread dependent on the value currently loaded can be reordered before this load</u>. This ensures that writes to data-dependent variables in other threads that release the same atomic variables are visible in the current thread. On most platforms, this affects compiler optimizations only.</p></li>
<li><p><strong><code>memory_order_acquire</code></strong>: a <u>load</u> operation with this memory order performs the <em>acquire operation</em> on the affected mem loc: <u>no mem accesses in the current thread can be reordered before this load</u>. This ensures that all writes in other threads that release the same atomic variables are visible in the current thread.</p></li>
<li><p><strong><code>memory_order_release</code></strong>: a <u>store</u> operation with this mem order performs the <em>release operation</em>: <u>no mem accesses in the current thread can be reordered after this store</u>. This ensures that all writes in the current thread are visible in other threads that acquire the same atomic variables and writes that carry a dependency into the atomic variable become visible in other threads that consume the same atomic.</p></li>
<li><p><strong><code>memory_order_acq_rel</code></strong>: a <u>read-modify-write</u> operation with this mem order is both <em>acquire operation</em> and a <em>release operation</em>. <u>No mem accesses in the current thread can be reordered before this load</u>, and <u>no mem accesses in the current thread can be reordered after this store</u>. It is ensured that all writes in other threads that release the same atomic variable are visible before the modification and the modification is visible in other threads that acquire the same atomic variable.</p></li>
<li><p><code>memory_order_seq_cst</code>: same as <code>memory_order_acq_rel</code>, plus a <u>single total order</u> exists in which all threads observe all modification in the same order.</p></li>
</ul>

<p><strong>relaxed ordering</strong>  </p>

<pre class=" language-cpp"><code class=" language-cpp"> <span class="token comment" spellcheck="true">//x and y intially zero</span>
 
 <span class="token comment" spellcheck="true">// Thread 1:</span>
 r1 <span class="token operator">=</span> y<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// A</span>
 x<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span>r1<span class="token punctuation">,</span> memory_order_relaxed<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// B</span>
 <span class="token comment" spellcheck="true">// Thread 2:</span>
 r2 <span class="token operator">=</span> x<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>memory_order_relaxed<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// C</span>
 y<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">,</span> memory_order_relaxed<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// D</span></code></pre>

<p>is allowed to produce <code>r1==r2==42</code> (i.e., <code>D-A-B-C</code>) because, although <code>A</code> is <em>sequenced-before</em> <code>B</code> within thread 1, and <code>C</code> is <em>sequenced-before</em> <code>D</code> within thread 2, nothing prevents <code>D</code> from appearing before <code>A</code> in the modification order of y, and <code>B</code> before <code>C</code> in the modification order of x. The side-effect of <code>D</code> on y could be visible to the load <code>A</code> in Thread 1 while the side-effect of <code>B</code> on x could be visible to the load <code>C</code> in Thread 2.</p>

<p><strong>release-acquire ordering</strong><br>
if an atomic store in thread A is tagged <code>memory_order_release</code> and an atomic load in thread B from the same variable is tagged <code>memory_order_acquire</code>, all mem writes (non-atomic and relaxed atomic) that <em>happend-before</em> the atomic store from the point of view of thread A, become <em>visible side-effect</em> in thread B, that is, once the atomic load is completed, thread B is guaranteed to see everything thread A wrote to mem.</p>

<script type="text/javascript">
var _self="undefined"!=typeof window?window:"undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope?self:{},Prism=function(){var e=/\blang(?:uage)?-(?!\*)(\w+)\b/i,t=_self.Prism={util:{encode:function(e){return e instanceof n?new n(e.type,t.util.encode(e.content),e.alias):"Array"===t.util.type(e)?e.map(t.util.encode):e.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/\u00a0/g," ")},type:function(e){return Object.prototype.toString.call(e).match(/\[object (\w+)\]/)[1]},clone:function(e){var n=t.util.type(e);switch(n){case"Object":var a={};for(var r in e)e.hasOwnProperty(r)&&(a[r]=t.util.clone(e[r]));return a;case"Array":return e.map&&e.map(function(e){return t.util.clone(e)})}return e}},languages:{extend:function(e,n){var a=t.util.clone(t.languages[e]);for(var r in n)a[r]=n[r];return a},insertBefore:function(e,n,a,r){r=r||t.languages;var l=r[e];if(2==arguments.length){a=arguments[1];for(var i in a)a.hasOwnProperty(i)&&(l[i]=a[i]);return l}var o={};for(var s in l)if(l.hasOwnProperty(s)){if(s==n)for(var i in a)a.hasOwnProperty(i)&&(o[i]=a[i]);o[s]=l[s]}return t.languages.DFS(t.languages,function(t,n){n===r[e]&&t!=e&&(this[t]=o)}),r[e]=o},DFS:function(e,n,a){for(var r in e)e.hasOwnProperty(r)&&(n.call(e,r,e[r],a||r),"Object"===t.util.type(e[r])?t.languages.DFS(e[r],n):"Array"===t.util.type(e[r])&&t.languages.DFS(e[r],n,r))}},plugins:{},highlightAll:function(e,n){for(var a,r=document.querySelectorAll('code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'),l=0;a=r[l++];)t.highlightElement(a,e===!0,n)},highlightElement:function(n,a,r){for(var l,i,o=n;o&&!e.test(o.className);)o=o.parentNode;o&&(l=(o.className.match(e)||[,""])[1],i=t.languages[l]),n.className=n.className.replace(e,"").replace(/\s+/g," ")+" language-"+l,o=n.parentNode,/pre/i.test(o.nodeName)&&(o.className=o.className.replace(e,"").replace(/\s+/g," ")+" language-"+l);var s=n.textContent,u={element:n,language:l,grammar:i,code:s};if(!s||!i)return t.hooks.run("complete",u),void 0;if(t.hooks.run("before-highlight",u),a&&_self.Worker){var g=new Worker(t.filename);g.onmessage=function(e){u.highlightedCode=e.data,t.hooks.run("before-insert",u),u.element.innerHTML=u.highlightedCode,r&&r.call(u.element),t.hooks.run("after-highlight",u),t.hooks.run("complete",u)},g.postMessage(JSON.stringify({language:u.language,code:u.code,immediateClose:!0}))}else u.highlightedCode=t.highlight(u.code,u.grammar,u.language),t.hooks.run("before-insert",u),u.element.innerHTML=u.highlightedCode,r&&r.call(n),t.hooks.run("after-highlight",u),t.hooks.run("complete",u)},highlight:function(e,a,r){var l=t.tokenize(e,a);return n.stringify(t.util.encode(l),r)},tokenize:function(e,n){var a=t.Token,r=[e],l=n.rest;if(l){for(var i in l)n[i]=l[i];delete n.rest}e:for(var i in n)if(n.hasOwnProperty(i)&&n[i]){var o=n[i];o="Array"===t.util.type(o)?o:[o];for(var s=0;s<o.length;++s){var u=o[s],g=u.inside,c=!!u.lookbehind,f=0,h=u.alias;u=u.pattern||u;for(var p=0;p<r.length;p++){var d=r[p];if(r.length>e.length)break e;if(!(d instanceof a)){u.lastIndex=0;var m=u.exec(d);if(m){c&&(f=m[1].length);var y=m.index-1+f,m=m[0].slice(f),v=m.length,k=y+v,b=d.slice(0,y+1),w=d.slice(k+1),P=[p,1];b&&P.push(b);var A=new a(i,g?t.tokenize(m,g):m,h);P.push(A),w&&P.push(w),Array.prototype.splice.apply(r,P)}}}}}return r},hooks:{all:{},add:function(e,n){var a=t.hooks.all;a[e]=a[e]||[],a[e].push(n)},run:function(e,n){var a=t.hooks.all[e];if(a&&a.length)for(var r,l=0;r=a[l++];)r(n)}}},n=t.Token=function(e,t,n){this.type=e,this.content=t,this.alias=n};if(n.stringify=function(e,a,r){if("string"==typeof e)return e;if("Array"===t.util.type(e))return e.map(function(t){return n.stringify(t,a,e)}).join("");var l={type:e.type,content:n.stringify(e.content,a,r),tag:"span",classes:["token",e.type],attributes:{},language:a,parent:r};if("comment"==l.type&&(l.attributes.spellcheck="true"),e.alias){var i="Array"===t.util.type(e.alias)?e.alias:[e.alias];Array.prototype.push.apply(l.classes,i)}t.hooks.run("wrap",l);var o="";for(var s in l.attributes)o+=(o?" ":"")+s+'="'+(l.attributes[s]||"")+'"';return"<"+l.tag+' class="'+l.classes.join(" ")+'" '+o+">"+l.content+"</"+l.tag+">"},!_self.document)return _self.addEventListener?(_self.addEventListener("message",function(e){var n=JSON.parse(e.data),a=n.language,r=n.code,l=n.immediateClose;_self.postMessage(t.highlight(r,t.languages[a],a)),l&&_self.close()},!1),_self.Prism):_self.Prism;var a=document.getElementsByTagName("script");return a=a[a.length-1],a&&(t.filename=a.src,document.addEventListener&&!a.hasAttribute("data-manual")&&document.addEventListener("DOMContentLoaded",t.highlightAll)),_self.Prism}();"undefined"!=typeof module&&module.exports&&(module.exports=Prism),"undefined"!=typeof global&&(global.Prism=Prism);
</script>
<script type="text/javascript">
Prism.languages.clike={comment:[{pattern:/(^|[^\\])\/\*[\w\W]*?\*\//,lookbehind:!0},{pattern:/(^|[^\\:])\/\/.*/,lookbehind:!0}],string:/(["'])(\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,"class-name":{pattern:/((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[a-z0-9_\.\\]+/i,lookbehind:!0,inside:{punctuation:/(\.|\\)/}},keyword:/\b(if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,"boolean":/\b(true|false)\b/,"function":/[a-z0-9_]+(?=\()/i,number:/\b-?(?:0x[\da-f]+|\d*\.?\d+(?:e[+-]?\d+)?)\b/i,operator:/--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|\^|%/,punctuation:/[{}[\];(),.:]/};
</script>
<script type="text/javascript">
Prism.languages.c=Prism.languages.extend("clike",{keyword:/\b(asm|typeof|inline|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|union|unsigned|void|volatile|while)\b/,operator:/\-[>-]?|\+\+?|!=?|<<?=?|>>?=?|==?|&&?|\|?\||[~^%?*\/]/,number:/\b-?(?:0x[\da-f]+|\d*\.?\d+(?:e[+-]?\d+)?)[ful]*\b/i}),Prism.languages.insertBefore("c","string",{macro:{pattern:/(^\s*)#\s*[a-z]+([^\r\n\\]|\\.|\\(?:\r\n?|\n))*/im,lookbehind:!0,alias:"property",inside:{string:{pattern:/(#\s*include\s*)(<.+?>|("|')(\\?.)+?\3)/,lookbehind:!0},directive:{pattern:/(#\s*)\b(define|elif|else|endif|error|ifdef|ifndef|if|import|include|line|pragma|undef|using)\b/,lookbehind:!0,alias:"keyword"}}},constant:/\b(__FILE__|__LINE__|__DATE__|__TIME__|__TIMESTAMP__|__func__|EOF|NULL|stdin|stdout|stderr)\b/}),delete Prism.languages.c["class-name"],delete Prism.languages.c["boolean"];
</script>
<script type="text/javascript">
Prism.languages.cpp=Prism.languages.extend("c",{keyword:/\b(alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|class|compl|const|constexpr|const_cast|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|float|for|friend|goto|if|inline|int|long|mutable|namespace|new|noexcept|nullptr|operator|private|protected|public|register|reinterpret_cast|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|union|unsigned|using|virtual|void|volatile|wchar_t|while)\b/,"boolean":/\b(true|false)\b/,operator:/[-+]{1,2}|!=?|<{1,2}=?|>{1,2}=?|\->|:{1,2}|={1,2}|\^|~|%|&{1,2}|\|?\||\?|\*|\/|\b(and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\b/}),Prism.languages.insertBefore("cpp","keyword",{"class-name":{pattern:/(class\s+)[a-z0-9_]+/i,lookbehind:!0}});
</script>



</body></html>